---
layout:     post
title:      "面试汇总"
subtitle:   ""
author:     "wangdongxu"
header-img: "img/about-bg.jpg"
toc: true
tags:
    - 面试
---

# 腾讯一面

```
排序：冒泡、快排、heap
floyd动态规划

进程通信方式
读写锁
select实现
select和epoll、epoll支持水平触发和边缘触发

tcp的rst: https://my.oschina.net/costaxu/blog/127394
linux命令
tcpdump抓某个端口，某个区域
gdb调试
10进制大数转化到16进制
```

# C/C++编程基础

## c++代码到可执行文件

```
源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件
a.cpp---------------------------a.asm-----a.o
                                             ------ab
b.cpp---------------------------b.asm-----b.o

* 预处理：带#号的
	* 宏定义#define
	* 条件编译#ifdef,#ifndef,#else,#elif,#endif
	* 头文件包含#include<>和#include""
* 编译：词法分析、语法分析。确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。
* 优化：循环优化等
* 汇编：汇编语言代码翻译成目标机器指令的过程
* 链接(静态、动态)
	* 链接程序的主要工作就是将有关的目标文件彼此相连接
	* 某个源文件中的函数可能引用了另一个源文件中定义的某个符号
	* 在程序中可能调用了某个库文件中的函数
```

## c++如何调用c语言函数

```c++
// 1. 头文件 前加上 extern “C”
// 2. 函数声明 前加上extern “C”。函数实现可以不用
extern “C”
{
	#include “s.h”
	#include “t.h”
	#include “g.h”
	#include “j.h”
};
extern “C”
{
	extern void A_app（int）;
	extern void B_app（int）;
	extern void C_app（int）;
	extern void D_app（int）;
}
```
## 值传递、指针传递、引用传递（c++独有）

```c++
void swap1(int a, int b)	//值传递
{
     int temp;
     temp=a;
     a=b;
     b=temp;
}
void swap2(int *ap, int *bp)	//指针传递
{
     int temp;
     temp=*ap;
     *ap=*bp;
     *bp=temp;
}
void swap3(int &a, int &b)		//引用传递
{
     int temp;
     temp=a;
     a=b;
     b=temp;
}
int main()
{
    int x=1;
    int y=2;
    
    swap1(x,y);
    swap2(&x,&y);
    swap3(x,y);
    
    return 0;
}
```
## 引用、指针区别？

```
引用必须被初始化，指针不必。
引用初始化以后不能被改变，指针可以改变所指的对象。
不存在指向空值的引用，但是存在指向空值的指针。
```
## 变量存储位置

```c++
// http://blog.csdn.net/hairetz/article/details/4141043
// http://www.cleey.com/blog/single/id/776.html

int a = 0; //全局初始化区   .data字段
char *p1;  //全局未初始化区 .bss字段
main() 
{ 
  	// b, s, p2, p3在栈上
    int b;
    char s[] = "abc";
    char *p2;
    char *p3 = "123456"; // "123456\0"在常量区，p3在栈上
    static int c = 0；    //全局（静态）初始化区
    
    p1 = (char *)malloc(10); //堆
}
```
## malloc/free

```c++
// C语言中，数组长度必须在创建数组时指定，并且只能是一个常数，不能是变量。一旦定义了一个数组，系统将为它分配一个固定大小的空间，以后不能改变，称为静态数组。但在编程过程中，有时我们所需的内存空间无法预先确定，对于这个问题，用静态数组的办法很难解决。

// 动态数组是相对于静态数组而言。静态数组的长度是预先定义好的，在整个程序中，一旦给定大小后就无法改变。而动态数组则不然，它可以随程序需要而重新指定大小。动态数组的内存空间是从堆(heap)上分配(即动态分配)的。是通过执行代码而为其分配存储空间。当程序执行到这些语句时，才为其分配。程序员自己负责释放内存。

int main()
{
    // 动态分配内存空间，如果失败就退出程序
    int *array;  // 数组指针
    array = (int *)malloc( 100 * sizeof(int) );
    // 和int array[100];一样
    
    // 向内存中写入数据
    for(i=0; i<arrLen; i++)
        array[i] = i+1;
    
    // 循环输出数组元素
    for(i=0; i<arrLen; i++)
        printf("%d  ", array[i]);
 
 	 //必须释放！！！
    free(array); 
    return 0;
}
```
## new/delete

```c++
参考http://www.cnblogs.com/hazir/p/new_and_delete.html
new 和 delete 是函数吗？
new [] 和 delete [] 又是什么？

// 对应关系
new     <-->  delete
new[]   <-->  delete[]
malloc  <-->  free

// 用法
int *a = new int;
delete a;
string *psa = new string[10];      //array of 10 empty strings
int *pia = new int[10];            //array of 10 uninitialized ints
delete [] psa;
delete [] pia;
```
## delete 和 C 的 free 区别

```
free对应的是malloc
delete对应的是new

共同点：它们都会把指针所指向的内存释放掉

应用的区别为：
1. 在类和对象的时候会有很大区别：在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。
2. 数组的时候：int *p=(int*)malloc(10*sizeof(int)) 释放的时候 free(p)即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当int *p=new int[10]释放的时候应为delete []p，注意[]的作用说明释放的是一个数组的内存，如果delete p则只是释放的p[0]，其余9个int的内存没有释放；这是因为当指明为[]的时候，编译器实际上是做了一个循环来释放这个数组的所有内存。

```

## 防止内存泄漏的方法

```c
内存问题：http://blog.csdn.net/u010229677/article/details/9000584
https://zh.wikipedia.org/wiki/内存泄漏
疏忽或错误造成程序未能释放已经不再使用的内存
内存泄漏会因为减少可用内存的数量从而降低计算机的性能。最终，在最糟糕的情况下，过多的可用内存被分配掉导致全部或部分设备停止正常工作，或者应用程序崩溃

// C
void f(void)
 {
     void* s;
     s = malloc(50); /* 申请内存空间 */
     return;  /* 内在泄漏 - 参见以下资料 */ 
     /* 
      * s 指向新分配的堆空间。
      * 当此函数返回，离开局部变量s的作用域后将无法得知s的值，
      * 分配的内存空间不能被释放。
      *
      * 如要「修复」这个问题，必须想办法释放分配的堆空间，
      * 也可以用alloca(3)代替malloc(3)。
      * （注意：alloca(3)既不是ANSI函数也不是POSIX函数）
      */
 }
 int main(void)
 {
     /* 该函数是一个死循环函数 */
     while (true) f(); /* Malloc函数迟早会由于内存泄漏而返回NULL*/
     return 0;
 }
 
// C++
#include <iostream>
using namespace std;
int main()
{ 
   int *a = new int(123);
   cout << *a << endl;
   // We should write "delete a;" here
   a = new int(456);
   cout << *a << endl;
   delete a;
   return 0;
}
```
## 模板

```c++
//http://www.runoob.com/cplusplus/cpp-templates.html
//模板是泛型编程的基础

#include <iostream>
#include <string>
 
using namespace std;
 
template <typename T>
inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
}
 
int main ()
{
    int i = 39;
    int j = 20;
    cout << "Max(i, j): " << Max(i, j) << endl; 
 
    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 
 
    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 
 
   return 0;
}
```
## 重载

```c++
在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同
#include <iostream>
using namespace std;
 
class printData 
{
   public:
      void print(int i) {
        cout << "整数为: " << i << endl;
      }
 
      void print(double  f) {
        cout << "浮点数为: " << f << endl;
      }
 
      void print(string c) {
        cout << "字符串为: " << c << endl;
      }
};
 
int main(void)
{
   printData pd;
 
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   pd.print("Hello C++");
 
   return 0;
}
```

##类

http://www.runoob.com/cplusplus/cpp-classes-objects.html

### 类的定义、对象的定义

成员、成员变量、成员函数

```c++
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;   // 长度
      double breadth;  // 宽度
      double height;   // 高度
      
      // 成员函数声明
      double getVolume(void);
      void setLength( double len );
      void setBreadth( double bre );
      void setHeight( double hei );
};


// 成员函数定义
double Box::getVolume(void)
{
    return length * breadth * height;
}

void Box::setLength( double len )
{
    length = len;
}

void Box::setBreadth( double bre )
{
    breadth = bre;
}

void Box::setHeight( double hei )
{
    height = hei;
}

 
int main( )
{
   Box Box1;        // 声明 Box1，类型为 Box
   Box Box2;        // 声明 Box2，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   {
   		// box 1 详述
	   Box1.height = 5.0; 
	   Box1.length = 6.0; 
	   Box1.breadth = 7.0;
	 
	   // box 2 详述
	   Box2.height = 10.0;
	   Box2.length = 12.0;
	   Box2.breadth = 13.0;
	 
	   // box 1 的体积
	   volume = Box1.height * Box1.length * Box1.breadth;
	   cout << "Box1 的体积：" << volume <<endl;
	 
	   // box 2 的体积
	   volume = Box2.height * Box2.length * Box2.breadth;
	   cout << "Box2 的体积：" << volume <<endl;
   }
   
  	{
  		// box 1 详述
	   Box1.setLength(6.0); 
	   Box1.setBreadth(7.0); 
	   Box1.setHeight(5.0);
	
	   // box 2 详述
	   Box2.setLength(12.0); 
	   Box2.setBreadth(13.0); 
	   Box2.setHeight(10.0);
	
	   // box 1 的体积
	   volume = Box1.getVolume();
	   cout << "Box1 的体积：" << volume <<endl;
	
	   // box 2 的体积
	   volume = Box2.getVolume();
	   cout << "Box2 的体积：" << volume <<endl;
  	}
   return 0;
}
```

### C++ 类访问修饰符构造函数

```
继承中的特点
有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。
1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private
但无论哪种继承方式，上面两点都没有改变：
1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
2.protected 成员可以被派生类访问。
```
### 构造函数 & 析构函数

```
类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。
构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。
http://www.runoob.com/cplusplus/cpp-constructor-destructor.html
```
### 拷贝构造函数

拷贝构造函数为什么使用引用类型

```
http://www.runoob.com/cplusplus/cpp-copy-constructor.html
拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：
通过使用另一个同类型的对象来初始化新创建的对象。
复制对象把它作为参数传递给函数。
复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：
```
### 深拷贝、浅靠背

```
https://www.zhihu.com/question/36370072 蓝色
```
### 运算符重载

http://www.runoob.com/cplusplus/cpp-overloading.html

### this指针

http://www.runoob.com/cplusplus/cpp-this-pointer.html


## 多态
* 继承：http://www.runoob.com/cplusplus/cpp-inheritance.html
* 虚函数，c++虚函数有什么用？纯虚函数：http://www.runoob.com/cplusplus/cpp-polymorphism.html
* 静态成员函数不能声明为虚函数：http://www.runoob.com/cplusplus/cpp-static-members.html

# 计算机网络
* 应用层协议
* DNS原理https://michaelyou.github.io/2015/03/19/DNS原理及其解析过程
* TCP重发机制
* linux软硬链接的区别？
* socket通信
* socket实现过程，具体用的方法；怎么实现异步socket.


# 操作系统
## 生产者消费者代码怎么写

## 什么是死锁，必要条件，解决方法

```
 所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面
 产生死锁的必要条件
 从以上分析可见，如果在计算机系统中同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。
    〈1〉互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。
    〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。
    〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。
    〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待
```
## 进程、线程

### 1.什么是进程？什么是线程？

进程是表示资源分配的基本单位，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的并发执行的单位。
在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。
线程概念
　　线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。例如，假设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是一个子任务；在产生工资单报表的过程中，用户又可以输人数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求――工资单报表和新输人的数据查询表示为数据库进程中的独立的线程。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性。
 举个例子来说多线程就像是火车上的每节车厢，而进程就是火车。

#### 谈谈对进程的理解？

答：首先进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位，进程有五方面的特点：第一：动态性:进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。第二： 并发性:任何进程都可以同其他进程一起并发执行第三：独立性:进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位;第四：异步性:由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进第五：结构特征:进程由程序、数据和进程控制块三部分组成。进程可以使用fork（）函数来创建子进程也可以使用vfork（）来实现进程，使用的时候注意不要产生僵尸进程和孤儿进程。

#### 谈谈对线程的理解？

答：线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流，线程有四方面特点：第一，线程有独立的堆栈段，共享地址空间，开销较小，切换速度较快。第二，线程间的通信机制比较方便。第三，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。线程使CPU系统更加有效。第四,线程改善了程序结构，避免了一些嵌套循环。使用pthread_create()函数来创建线程，使用线程的时候有两点注意事项：第一，当多线程访问同一全局变量的时候，一定要加互斥量，也就是上锁。当然最后不要忘记了解锁。第二：正确处理线程结束的问题：因为一个线程的终止，线程的资源不会随线程的终止释放，我们需要调用pthread_join() 来获得另一个线程的终止状态并且释放该线程所占的资源。

#### 进程死锁的原因？如何解决进程死锁？

答：首先呢进程有三态：执行状态，就绪状态，等待状态。。进程因等待资源的时候而睡眠进入等待状态，只有资源到来的时候才会唤醒进入就绪状态，进程死锁就会发生在这个阶段，如果多个进程同时占有对方需要的资源而同时请求对方的资源，而它们在得到请求之前不会释放所占有的资源，就会发生进程死锁，也就是进程不同步。
原因有两方面：1.系统能够提供的资源个数比要求该资源的进程少，即系统资源不足
2.进程推进顺序非法。
解决方案：因为进程死锁的发生有四个条件：
1.互斥条件：资源不能被共享，只能由一个进程使用。
2.请求与保持条件：已经得到资源的进程可以再次申请新的资源。
3.非剥夺条件：已经分配的资源不能从相应的进程中被强制地剥夺。
4.循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
所以我们可以从这几个方面着手去解决：
第一：根据互斥条件和请求和保持条件，我们可以采用资源静态分配策略，破坏"部分分配"条件；
第二：允许进程剥夺使用其他进程占有的资源，从而破坏"不可剥夺"条件；
第三：采用资源有序分配法，破坏"环路"条件。当然我们也不是必须严格遵循这几个必要条件去使用相对的侧列，我们也可以使用死锁检测方法，对资源的分配不加限制，即允许死锁的发生。但系统定时地运行一个"死锁检测"程序，判断系统是否已发生死锁，若检测到死锁发生则设法加以解除，可以使用资源剥夺法和撤销进程法来解除死锁。

### 2.多进程和多线程的区别？

我们从各个方面来看待这个问题，由下面的图片说明：
对比维度
多进程
多线程
总结
数据共享、同步
数据共享复杂，需要用IPC；数据是分开的，同步简单
因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂
各有优势
内存、CPU
占用内存多，切换复杂，CPU利用率低
占用内存少，切换简单，CPU利用率高
线程占优
创建销毁、切换
创建销毁、切换复杂，速度慢
创建销毁、切换简单，速度很快
线程占优
编程、调试
编程简单，调试简单
编程复杂，调试复杂
进程占优
可靠性
进程间不会互相影响
一个线程挂掉将导致整个进程挂掉
进程占优
分布式
适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单
适应于多核分布式
进程占优

### 3.进程之间的通信方式以及优缺点？

1)管道
管道分为有名管道和无名管道
无名管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用.进程的亲缘关系一般指的是父子关系。无明管道一般用于两个不同进程之间的通信。当一个进程创建了一个管道,并调用fork创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样提供了两个进程之间数据流动的一种方式。
有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。

无名管道：优点：简单方便；缺点：1）局限于单向通信2）只能创建在它的进程以及其有亲缘关系的进程之间;3）缓冲区有限；
有名管道：优点：可以实现任意关系的进程间的通信；缺点：1）长期存于系统中，使用不当容易出错；2）缓冲区有限
2)信号量
信号量是一个计数器,可以用来控制多个线程对共享资源的访问.,它不是用于交换大批数据,而用于多线程之间的同步.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.
优点：可以同步进程；缺点：信号量有限

3)信号
信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.

4)消息队列
消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.消息队列是UNIX下不同进程之间可实现共享资源的一种机制,UNIX允许不同进程将格式化的数据流以消息队列形式发送给任意进程.对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制.通过使用消息类型,进程可以按任何顺序读信息,或为消息安排优先级顺序.

优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便；缺点：信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合

5)共享内存
共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是最快的IPC(进程间通信)方式,它是针对其它进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信.

优点：无须复制，快捷，信息量大；缺点：1）通信是通过将共无法实现享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题；2)利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

6)套接字：可用于不同及其间的进程通信
优点：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强
缺点：1) 需对传输的数据进行解析，转化成应用级的数据。

### 4.线程之间的通信方式？

锁机制：包括互斥锁、条件变量、读写锁
   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
信号机制(Signal)：类似进程间的信号处理
    线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 5.什么时候用多线程?什么时候用多进程？

1）需要频繁创建销毁的优先用线程
原因请看上面的对比。
这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2）需要进行大量计算的优先使用线程
所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
这种原则最常见的是图像处理、算法处理。
3）强相关的处理用线程，弱相关的处理用进程
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。
4）可能要扩展到多机分布的用进程，多核分布的用线程
原因请看上面对比。
5）都满足需求的情况下，用你最熟悉、最拿手的方式
至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。

#算法

* 队列和堆、栈
* 一个字符串查找出现一次的字符
* 找出第一个不重复的字符串
* 二分查找(假设1至100)里面哪些数或哪类数的查找次数是最多的，或者说很难查找的
* DFS BFS
* 排序&稳定性：冒泡、选择、快速排序、堆排序
* 对一个基本有序的数组应该采用什么方式进行排序，对一个乱序的数组应该采用什么方式排序能快速找到前n个数？为什么？
* 两个链表有序，去重进行合并
* 怎么实现环形队列
#数据库
* 数据表定义字段会有1到100的可变长度，用什么数据类型？为什么？
* ddl dcl dml是什么？分别举例子？
* delete drop truncate区别？http://www.jianshu.com/p/9d6c6e5d676f
* 索引，优缺点？BTree
* 事务（4个特性ACID）

```
事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。 
事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。 

事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。 
1 、原子性 
事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 
2 、一致性 
事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 
3 、隔离性 
一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 
4 、持续性 
也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

脏读
不可重复读
虚读(幻读)
```
* 视图和表的区别

```
http://blog.csdn.net/fjseryi/article/details/12648013
```
* 内连接查询和外连接的区别
* select语句实现顺序

```
标准的 SQL 的解析顺序为:
(1)FROM 子句, 组装来自不同数据源的数据
(2)WHERE 子句, 基于指定的条件对记录进行筛选
(3)GROUP BY 子句, 将数据划分为多个分组
(4)使用聚合函数进行计算
(5)使用 HAVING 子句筛选分组
(6)计算所有的表达式
(7)使用 ORDER BY 对结果集进行排序
```

## 手写SQL
* 两个表有相同记录，如何去重       union和union all区别
* 输出用户表里重名的用户

```sql
select name, count(*) from table group by name having count(*) > 1
```

# 大数据
* 大数据处理软件：hadoop，hbase，spark
* 关系型数据库：orcale、sql server、mysql
* 非关系型数据库：redius、mongdb